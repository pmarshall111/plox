# A script to create C++ structs used in an AST

import subprocess
from typing import TypedDict


class ClassMember(TypedDict):
    type: str
    name: str


class ClassDef(TypedDict):
    name: str
    members: list[ClassMember]


def define_ast(
    out_file: str,
    guard_str: str,
    variant: str,
    namespaces: list[str],
    includes: list[str],
    classes: list[ClassDef],
) -> None:
    with open(out_file, "w+") as file:
        # Warning
        file.write(
            "// WARNING: DO NOT MANUALLY EDIT. This file is auto-generated by 'gen_ast_h.py'\n\n"
        )

        # Header guard
        with HeaderGuard(file, f"PLOX_AUTO_GENERATED_{guard_str.upper()}"):

            # Includes
            for inc in includes:
                file.write(f"#include <{inc}>\n\n")

            # Namespaces
            with NamespaceGuard(file, namespaces):

                # Forward declarations
                for cl in classes:
                    file.write(
                        f"""
                    struct {cl["name"]};
                    """
                    )

                # Variant definition
                file.write(
                    f"""
                    using {variant} = std::variant<{", ".join([cl["name"] for cl in classes])}>;
                    """
                )

                # Sub classes
                for cl in classes:
                    file.write(
                        f"""

                    struct {cl["name"]} {{
                        {"\n".join(f"\t{memb["type"]} {memb["name"]};" for memb in cl["members"])}
                    }};

                    """
                    )

    # Format output
    subprocess.run(["make", "format"], check=True)


# Guards to centralise logic for lines that occur at both the start and end of the file
class HeaderGuard:
    def __init__(self, file, name):
        self.file = file
        self.name = name

    def __enter__(self):
        self.file.write(
            f"""#ifndef {self.name}
        #define {self.name}

        """
        )

    def __exit__(self, *_):
        self.file.write(
            f"""
        #endif // {self.name}
        """
        )


class NamespaceGuard:
    def __init__(self, file, namespaces):
        self.file = file
        self.namespaces = namespaces

    def __enter__(self):
        self.file.write("\n".join([f"namespace {ns} {{" for ns in self.namespaces]))
        self.file.write("\n\n")

    def __exit__(self, *_):
        self.file.write("\n".join([f"}} // namespace {ns}" for ns in self.namespaces]))
        self.file.write("\n\n")


if __name__ == "__main__":
    # fmt: off
    define_ast("tree-walk/src/ast.h", "AST", "Expr", ["plox", "treewalk", "ast"], ["memory", "string", "variant", "scanner.h"], [
        {"name": "Assign", "members": [{"type": "std::string_view", "name": "name"}, {"type": "std::unique_ptr<Expr>", "name": "value"}]},
        {"name": "Binary", "members": [{"type": "std::unique_ptr<Expr>", "name": "left"}, {"type": "Token", "name": "op"}, {"type": "std::unique_ptr<Expr>", "name": "right"}]},
        {"name": "Call", "members": [{"type": "std::unique_ptr<Expr>", "name": "callee"}, {"type": "std::vector<std::unique_ptr<Expr>>", "name": "args"}]},
        {"name": "Get", "members": [{"type": "std::unique_ptr<Expr>", "name": "object"}, {"type": "std::string_view", "name": "property"}]},
        {"name": "Grouping", "members": [{"type": "std::unique_ptr<Expr>", "name": "expr"}]},
        {"name": "Literal", "members": [{"type": "std::string_view", "name": "value"}, {"type": "TokenType", "name": "type"}]},
        {"name": "Unary", "members": [{"type": "Token", "name": "op"}, {"type": "std::unique_ptr<Expr>", "name": "right"}]},
        {"name": "Variable", "members": [{"type": "std::string_view", "name": "name"}]}
    ])

    define_ast("tree-walk/src/stmt.h", "STMT", "Stmt", ["plox", "treewalk", "stmt"], ["ast.h", "memory", "variant"], [
        {"name": "Block", "members": [{"type": "std::vector<std::unique_ptr<stmt::Stmt>>", "name": "stmts"}]},
        {"name": "Class", "members": [{"type": "std::string_view", "name": "name"}, {"type": "std::vector<std::unique_ptr<stmt::Stmt>>", "name": "methods"}]},
        {"name": "Expression", "members": [{"type": "std::unique_ptr<ast::Expr>", "name": "expr"}]},
        {"name": "For", "members": [{"type": "std::unique_ptr<stmt::Stmt>", "name": "initialiser"}, {"type": "std::unique_ptr<ast::Expr>", "name": "condition"}, {"type": "std::unique_ptr<ast::Expr>", "name": "incrementer"}, {"type": "std::unique_ptr<stmt::Stmt>", "name": "body"}]},
        {"name": "Fun", "members": [{"type": "std::string_view", "name": "name"}, {"type": "std::vector<std::string_view>", "name": "params"}, {"type": "std::vector<std::unique_ptr<stmt::Stmt>>", "name": "stmts"}, {"type": "bool", "name": "isMethod"}]},
        {"name": "If", "members": [{"type": "std::unique_ptr<ast::Expr>", "name": "condition"}, {"type": "std::unique_ptr<stmt::Stmt>", "name": "ifBranch"}, {"type": "std::unique_ptr<stmt::Stmt>", "name": "elseBranch"}]},
        {"name": "Print", "members": [{"type": "std::unique_ptr<ast::Expr>", "name": "expr"}]},
        {"name": "Return", "members": [{"type": "std::unique_ptr<ast::Expr>", "name": "expr"}]},
        {"name": "VarDecl", "members": [{"type": "std::string_view", "name": "name"}, {"type": "std::unique_ptr<ast::Expr>", "name": "expr"}]},
        {"name": "While", "members": [{"type": "std::unique_ptr<ast::Expr>", "name": "condition"}, {"type": "std::unique_ptr<stmt::Stmt>", "name": "body"}]},
    ])
    # fmt: on
